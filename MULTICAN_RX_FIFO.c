/********************************************************************************************************************
 * \file MULTICAN_RX_FIFO.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MULTICAN_RX_FIFO.h"
#include "CPU_Perf_Counters.h"
#include <stdio.h>

#define MOVEAVG 1

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
AppMulticanType             g_multican;
IfxPort_Pin_Config          g_led1;
CanCommunicationStatusType  g_status = CanCommunicationStatus_Success;
const uint32                g_canInitialMessageData[2] = {0xDA7A0000, 0xBA5E0000};  /* Dummy values */
IfxCpu_Perf g_perfCounts;                       /* Need to be global to display in the Watch View of the debugger   */
uint8 local_windowSize = 100;                   /* This is static, because I need to memorize it (and clear it) for the incoming signal */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
/* NOTE: the vector table number parameter (vectabNum) must match the CPU index that is servicing the ISR */
IFX_INTERRUPT(canIsrOverflowHandler, 0, ISR_PRIORITY_CAN_OVERFLOW);

static void movingAverage(uint8 data[], uint8 filteredData[], uint8 dataSize, uint8 windowSize) {
    for (uint8 i = windowSize - 1; i < dataSize; ++i) {
        uint16 sum = 0;
        for (uint8 j = 0; j < windowSize; ++j) {
            sum += data[i - j];
        }
        filteredData[i] = sum / windowSize;
    }
}

/* Interrupt Service Routine (ISR) called once the RX interrupt has been generated.
 * Reads the received CAN message and, in case of no errors, increments the counter
 * to indicate the number of successfully received CAN messages.
 */
void canIsrOverflowHandler(void) {
//    IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
    enablePerfCountersWithMultiCount(
            0x000,  //  IP_DISPATCH_STALL
            0x000,  //  LS_DISPATCH_STALL
            0x011   //  DMEM_STALL
    );
    IfxMultican_Status readStatus;
    uint8 currentCanMessage;
    static volatile uint32 numOfReceivedMessages = 0; /* Static needed to hold the value through different ISR calls */

    for(currentCanMessage = 0; currentCanMessage < RX_FIFO_SIZE; currentCanMessage++) {
        /* Read the received CAN message and store the status of the operation */
        readStatus = IfxMultican_Can_MsgObj_readMessage(&g_multican.canDstMsgObj, &g_multican.rxMsg[currentCanMessage]);

        /* If no new data has been received, report an error */
        if(readStatus != IfxMultican_Status_newData) {
            g_status = CanCommunicationStatus_Error_noNewDataReceived;
            printf("No new data\n");
        }

        /* If a new data has been received but one message was lost, report an error */
        if(readStatus == IfxMultican_Status_newDataButOneLost) {
            g_status = CanCommunicationStatus_Error_newDataButOneLost;
            printf("New data but one lost\n");
        }

        /* If there was no error, increment the counter to indicate the number of successfully received CAN messages */
        if (g_status == CanCommunicationStatus_Success) {

//            printf("[%d] * ", numOfReceivedMessages);

            // ID: 0x777 - Random value between 0-7, toggling leds
            if(g_multican.rxMsg[currentCanMessage].id == 0x777) {
                uint8 led_number = g_multican.rxMsg[currentCanMessage].data[1] >> 24;
                IfxPort_togglePin(&MODULE_P33, PIN0 + led_number);
//                printf("Action on led #%d\n", led_number);

            }

            // ID: 0x700 - Window size value
            if(g_multican.rxMsg[currentCanMessage].id == 0x700) {
                local_windowSize = g_multican.rxMsg[currentCanMessage].data[0] & 0xffUL;
//                printf("Received a window size of %d.\n", local_windowSize);
            }

            //ID 0x722 - Values of the signal
            if(g_multican.rxMsg[currentCanMessage].id == 0x722) {
                // TODO: Some computation that varies according to integer value
                printf("[%lu] * ", numOfReceivedMessages);
#if !MOVEAVG
                uint8 n = g_multican.rxMsg[currentCanMessage].data[1] >> 24;
                uint64 a =  0, b = 1, c;
                for(int i = 1; i < n; i++) {
                  c = a+b; a = b; b = c;
                }
                printf("%d of fibonacci is %llu * ", n, a);
#else
                if(local_windowSize <= 8 && local_windowSize >= 1) {
                    uint8 resultData[8];
                    uint8 data[8];
                    // Reconstructing data from the uint32 values in the CAN node struct
                    // TODO: When doing this, we could also check for values range
                    // skipping the whole computation when we find a value not in range
                    // could lead to different HPCs, detectable by the IDS
    //                printf("%x %x\n", g_multican.rxMsg[currentCanMessage].data[0], g_multican.rxMsg[currentCanMessage].data[1]);
                    for(uint8 x = 0; x < 2; x++) {
                        for(uint8 y = 0; y < 4; y++) {
                            uint8 d = (g_multican.rxMsg[currentCanMessage].data[x] & (0xff << (y * 8))) >> (y * 8);
                            data[y + (x * 4)] = d;
                        }
                    }

                    movingAverage(data, resultData, 8, local_windowSize);
                }
                local_windowSize = 100;
                // TODO: handle result somehow
#endif
            }

//            printf("[%lu] ID: 0x%lx | DLS: %d | DATA: %lx %lx\n", numOfReceivedMessages, g_multican.rxMsg[currentCanMessage].id, g_multican.rxMsg[currentCanMessage].lengthCode, g_multican.rxMsg[currentCanMessage].data[0], g_multican.rxMsg[currentCanMessage].data[1]);
            numOfReceivedMessages++;

//            if(numOfReceivedMessages == NUMBER_OF_RECEIVED_MESSAGES)
//            {
//                g_allMessagesReceived = TRUE;
//            }
        }
    }

    g_perfCounts = IfxCpu_stopCounters();
    printPerfCounters(g_perfCounts, 0);
}

/* Function to initialize the MULTICAN module, nodes and message objects related for this application use case */
void initMultican(void)
{
    Ifx_CAN_MO *hwObj;

    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - define the interrupt priority for interrupt node pointer used in the example
     *  - define the interrupt service provider that should handle the interrupt service request
     *  - initialize CAN module with the modified configuration
     * ==========================================================================================
     */
    IfxMultican_Can_initModuleConfig(&g_multican.canConfig, &MODULE_CAN);

    g_multican.canConfig.nodePointer[OVERFLOW_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_OVERFLOW;
//    g_multican.canConfig.nodePointer[OVERFLOW_INTERRUPT_SRC_ID].typeOfService = ISR_PROVIDER_CAN_OVERFLOW;
    g_multican.canConfig.nodePointer[OVERFLOW_INTERRUPT_SRC_ID].typeOfService = 0;

    IfxMultican_Can_initModule(&g_multican.can, &g_multican.canConfig);

    /* ==========================================================================================
     * Common CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *  - set CAN node in the "Loop back" mode (no external pins are used)
     * ==========================================================================================
     */
//    IfxMultican_Can_Node_initConfig(&g_multican.canNodeConfig, &g_multican.can);

//    g_multican.canNodeConfig.loopBackMode = TRUE;

    /* ==========================================================================================
     * CAN node 0 configuration and initialization:
     * ==========================================================================================
     *  - assign node to CAN node 0
     *  - initialize the CAN node 0 with the modified configuration
     * ==========================================================================================
     */
//    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_0;
//
//    IfxMultican_Can_Node_init(&g_multican.canNode0, &g_multican.canNodeConfig);

    /* ==========================================================================================
     * CAN node 1 configuration and initialization:
     * ==========================================================================================
     *  - assign node to CAN node 1
     *  - initialize the CAN node 1 with the modified configuration
     * ==========================================================================================
     */

    IfxMultican_Can_Node_initConfig(&g_multican.canNodeConfig, &g_multican.can);

    g_multican.canNodeConfig.loopBackMode = FALSE;
    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_1;
    g_multican.canNodeConfig.txPin = &IfxMultican_TXD1_P14_0_OUT;
    g_multican.canNodeConfig.rxPin = &IfxMultican_RXD1B_P14_1_IN;

    IfxMultican_Can_Node_init(&g_multican.canNode1, &g_multican.canNodeConfig);

    /* =======================================================================================================
     * Source standard message object configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (same as ID used for RX FIFO base object)
     *  - define the message object as a transmit message object
     *
     *  - initialize the source standard CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 0
     * =======================================================================================================
     */
//    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode0);
//
//    g_multican.canMsgObjConfig.msgObjId = SRC_MESSAGE_OBJECT_ID;
//    g_multican.canMsgObjConfig.messageId = CAN_MESSAGE_ID;
//    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_transmit;
//
//    IfxMultican_Can_MsgObj_init(&g_multican.canSrcMsgObj, &g_multican.canMsgObjConfig);

    /* =======================================================================================================
     * RX FIFO structure configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (same as ID used for transmit message object)
     *  - define the size of the structure (more than 1 message object specifies FIFO structure)
     *  - define the message object as a receive message object (RX FIFO in this case)
     *  - define the first slave object ID as the next message object after RX FIFO base object
     *
     *  - initialize the CAN message objects with the modified configuration
     *
     *  - get the pointer of the RX FIFO base object
     *  - enable overflow interrupt generation
     *  - in case of RX FIFO base object, transmit interrupt node becomes active once overflow event occurs
     *  - place SET pointer at the first slave message object (once the whole RX FIFO buffer is filled,
     *    the overflow interrupt will be triggered)
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 1
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode1);

    g_multican.canMsgObjConfig.msgObjId = RX_FIFO_BASE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = CAN_MESSAGE_ID;
    g_multican.canMsgObjConfig.msgObjCount = RX_FIFO_SIZE;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_receive;
    g_multican.canMsgObjConfig.firstSlaveObjId = SLAVE_MESSAGE_OBJECT_ID;
    // Acceptance mask used to get all IDs in the 0x700 range
    g_multican.canMsgObjConfig.acceptanceMask = 0x70000000UL;

    IfxMultican_Can_MsgObj_init(&g_multican.canDstMsgObj, &g_multican.canMsgObjConfig);

    hwObj = IfxMultican_MsgObj_getPointer(g_multican.can.mcan, RX_FIFO_BASE_OBJECT_ID);
    IfxMultican_MsgObj_setOverflowInterrupt(hwObj, TRUE);
    IfxMultican_MsgObj_setTransmitInterruptNodePointer(hwObj, OVERFLOW_INTERRUPT_SRC_ID);
    IfxMultican_MsgObj_setSelectObjectPointer(hwObj, SLAVE_MESSAGE_OBJECT_ID);
}

/* Function to initialize and transmit CAN messages.
 * Before a CAN message is transmitted, a number of CAN messages need to be initialized.
 * The user can change the number of CAN messages by modifying NUMBER_OF_CAN_MESSAGES macro value.
 * The TX messages (messages that are transmitted) are initialized with the combination of predefined
 * content and current CAN message value. The RX messages (messages where the received CAN data is stored)
 * are initialized with invalid ID, data and length value. After successful CAN transmission, the values are
 * replaced with the valid content.
 */
void transmitCanMessages(void)
{
    uint8 currentCanMessage;

    /* Invalidation of the RX messages */
    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        IfxMultican_Message_init(&g_multican.rxMsg[currentCanMessage],
                                 INVALID_ID_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_LENGTH_VALUE);
    }

    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_GOOD_CAN_MESSAGES; currentCanMessage++)
    {
        /* Initialization of the TX message */
        IfxMultican_Message_init(&g_multican.txMsg,
                                 CAN_MESSAGE_ID,
                                 (g_canInitialMessageData[0] | (currentCanMessage % 8)),
                                 (g_canInitialMessageData[1] | (currentCanMessage % 8)),
                                 g_multican.canMsgObjConfig.control.messageLen);

//        /* Send the CAN message with the previously defined TX message content */
        while(IfxMultican_Status_notSentBusy ==
           IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj, &g_multican.txMsg))
        {
        }
    }

    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_BAD_CAN_MESSAGES; currentCanMessage++) {
        IfxMultican_Message_init(&g_multican.txMsg,
                                BAD_CAN_MESSAGE_ID,
                                BAD_DATA_VALUE,
                                BAD_DATA_VALUE,
                                 g_multican.canMsgObjConfig.control.messageLen);

        while(IfxMultican_Status_notSentBusy ==
           IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj, &g_multican.txMsg))
        {
        }
    }

//    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_TOTAL_CAN_MESSAGES; currentCanMessage++) {
//        while(IfxMultican_Status_notSentBusy ==
//          IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj, &g_multican.txMsg))
//       {
//       }
//    }
}

/*
 * Function that initializes the RX queue with invalid data
 */
void initRxQueue(void) {
    uint8 currentCanMessage;

    /* Invalidation of the RX messages */
    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        IfxMultican_Message_init(&g_multican.rxMsg[currentCanMessage],
                                 INVALID_ID_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_LENGTH_VALUE);
    }
}

/* Function to verify CAN messages.
 * After all the expected messages have been received by the RX FIFO, several checks are performed.
 *     - message ID check
 *     - message length check
 *     - data check (expected valid data and unchanged invalid data)
 */
void verifyCanMessages(void)
{
    uint8 currentCanMessage;

    /* Verification of the CAN messages is done in two steps while there are two ranges that need to be checked.
     *     - First "for" loop compares the valid expected data to the received data for the CAN messages in the
     *       [0, NUMBER_OF_RECEIVED_MESSAGES] range. NUMBER_OF_RECEIVED_MESSAGES defines the expected number of
     *       received CAN messages by the RX FIFO object that are read by the ISR. This number DOES NOT NEED to
     *       be equal to NUMBER_OF_CAN_MESSAGES (explanation is provided in the accompanying tutorial document).
     *
     *     - Second "for" loop checks the invalid data to make sure that the content has not been changed for the
     *       CAN messages in the [NUMBER_OF_RECEIVED_MESSAGES, NUMBER_OF_CAN_MESSAGES] range. Due to the fact that
     *       both ranges have NUMBER_OF_RECEIVED_MESSAGES in common, the initial value for the second "for" loop is
     *       not initialized.
     *
     * If both verification steps have been successful, LED1 is turned on to indicate correctness of the checks.
     */

    printf("-- Start batch --\n");
    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_RECEIVED_MESSAGES; currentCanMessage++)
    {
        /* Check if the received message ID does NOT match with the transmitted message ID.
         * If this is the case, an error should be reported.
         */
//        if(g_multican.rxMsg[currentCanMessage].id != CAN_MESSAGE_ID)
//        {
//            g_status = CanCommunicationStatus_Error_notExpectedMessageId;
//            break;
//        }

        /* Check if the received message length does NOT match with the expected message length.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].lengthCode != g_multican.canMsgObjConfig.control.messageLen)
        {
            g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            break;
        }

        /* Finally, check if the received data does NOT match with the transmitted one
         * If this is the case, an error should be reported.
         */
//        if((g_multican.rxMsg[currentCanMessage].data[0] != (g_canInitialMessageData[0] | (currentCanMessage % 8))) ||
//            (g_multican.rxMsg[currentCanMessage].data[1] != (g_canInitialMessageData[1] | (currentCanMessage % 8))))
//        {
//            g_status = CanCommunicationStatus_Error_notExpectedData;
//            break;
//        }

//        printf("ID: %lx - len: %lu - data: %lx %lx\n",
//                g_multican.rxMsg[currentCanMessage].id,
//                g_multican.rxMsg[currentCanMessage].lengthCode,
//                g_multican.rxMsg[currentCanMessage].data[0],
//                g_multican.rxMsg[currentCanMessage].data[1]);
    }

//    printf("second loop\n");
    for(/*...*/; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        /* Check if the received message ID does NOT match invalid ID value.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].id != INVALID_ID_VALUE)
        {
            g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            break;
        }

        /* Check if the received message length does NOT match invalid length value.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].lengthCode != INVALID_LENGTH_VALUE)
        {
            g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            break;
        }

        /* Finally, check if a received data does NOT match invalid data value.
         * If this is the case, an error should be reported.
         */
        if((g_multican.rxMsg[currentCanMessage].data[0] != INVALID_DATA_VALUE) ||
            (g_multican.rxMsg[currentCanMessage].data[1] != INVALID_DATA_VALUE))
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
            break;
        }

        printf("ID: %lx - len: %d - data: %lx %lx\n",
                g_multican.rxMsg[currentCanMessage].id,
                g_multican.rxMsg[currentCanMessage].lengthCode,
                g_multican.rxMsg[currentCanMessage].data[0],
                g_multican.rxMsg[currentCanMessage].data[1]);
    }
    printf("-- End batch --\n");

    /* If there was no error, turn on the LED1 to indicate correctness of the received messages */
    if(g_status == CanCommunicationStatus_Success)
    {
        IfxPort_setPinLow(g_led1.port, g_led1.pinIndex);
        initRxQueue();
    }
}

/* Function to initialize the port pin connected to the LED */
void initLed(void)
{
    /* ======================================================================
     * Configuration of the port pin connected to the LED:
     * ======================================================================
     *  - define the GPIO port
     *  - define the GPIO pin that is the connected to the LED
     *  - define the general GPIO pin usage (no alternate function used)
     *  - define the pad driver strength
     * ======================================================================
     */
    g_led1.port      = &MODULE_P33;
    g_led1.pinIndex  = PIN0;
    g_led1.mode      = IfxPort_OutputIdx_general;
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    uint8 i;
    /* Initialize the port pin connected to the LED to level "HIGH"; this keeps the LED turned off as default state */
    for(i = 0; i < 8; i++) {
        IfxPort_setPinHigh(g_led1.port, g_led1.pinIndex + i);
    }

    /* Set the pin input/output mode for the pin connected to the LED */
    for(i = 0; i < 8; i++) {
        IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex + i, IfxPort_OutputMode_pushPull, g_led1.mode);
    }

    /* Set the pad driver mode for the pin connected to the LED */
    for(i = 0; i < 8; i++) {
        IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex + i, g_led1.padDriver);
    }

}
